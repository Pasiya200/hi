 if (m.isBaileys && m.fromMe) return true
  let chat = global.db.data.chats[m.chat]
  let sender = global.db.data.chats[m.sender]
  

  let isSticker = m.mtype
  if (chat.antiSticker && isSticker) {
    if(isSticker === "stickerMessage"){
      if (global.opts) {
        if (isAdmin || !isBotAdmin){		  
        }else{
          m.reply('*Sticker detected*\nKamu akan bot keluar kan!') // ganti text terserah kamu 
          this.groupRemove(m.chat, [m.sender])
        }return true
      }
    }
  }
  return true
}


module.exports = {
    async all(m) {
        if (m.message && m.isBaileys && m.quoted && m.quoted.mtype === 'orderMessage' && !(m.quoted.token && m.quoted.orderId)) {
            m.reply('Bug Troli Detected\n\n' + require('util').format(m.key))
            // await this.clearMessage(m.chat, m.key)
            await this.modifyChat(m.chat, 'clear', {
                includeStarred: false
            }).catch(console.log)
        }
    }
}

 if (isCmd && msgFilter.isFiltered(from) && !isGroup) {
        console.log(color('[SPAM]', 'red'), color(time, 'yellow'), color(`${command} [${args.length}]`), 'from', color(pushname))
        return reply('„Äî ô·¥á ·¥ò·¥Ä·¥õ…™·¥á…¥·¥õ ùüª s·¥á·¥Ñ·¥è…¥·¥Ös/·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö„Äïîíù')}
        
        if (isCmd && msgFilter.isFiltered(from) && isGroup) {
        console.log(color('[SPAM]', 'red'), color(time, 'yellow'), color(`${command} [${args.length}]`), 'from', color(pushname), 'in', color(groupName))
        return reply('„Äî ô·¥á ·¥ò·¥Ä·¥õ…™·¥á…¥·¥õ ùüª s·¥á·¥Ñ·¥è…¥·¥Ös/·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö„Äïîíù')
        }

            if (!isGroup && !isCmd) console.log(color(time, 'white'), color('[ PRIVATE ]', 'aqua'), color(budy, 'white'), 'from', color(sender.split('@')[0], 'red'))
            if (isGroup && !isCmd) console.log(color([time], 'white'), color('[  GROUP  ]', 'aqua'), color(budy, 'white'), 'from', color(sender.split('@')[0], 'red'), 'in', color(groupName, 'white'))
            if (!isGroup && isCmd) console.log(color([time], 'white'), color('[ COMMAND ]', 'aqua'), color(budy, 'white'), 'from', color(sender.split('@')[0], 'red'))
            if (isGroup && isCmd) console.log(color([time], 'white'), color('[ COMMAND ]', 'aqua'), color(budy, 'white'), 'from', color(sender.split('@')[0], 'red'), 'in', color(groupName, 'white'))
            
            if (isCmd && !isOwner) msgFilter.addFilter(from)
            if (!isVerify) return reply(aml.noregis)
            if (isBanned) return reply(aml.baned)


            case 'suggest':
                if (isBanned) return reply(aml.baned)
                if (args.length < 1) return reply(`·¥° ú·¥Ä·¥õ ·¥Ö·¥è  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è s·¥ú…¢…¢·¥ás·¥õ ·¥õ·¥è ·¥õ ú·¥á ·¥è·¥°…¥·¥á Ä?`)
				const psn = body.slice(9)
				var nmr = Mel.participant
				const tks1 = `[s·¥ú…¢…¢·¥ás·¥õ…™·¥è…¥]\n…¥·¥ú·¥ç ô·¥á Ä : @${nmr.split('@s.whatsapp.net')[0]}\n·¥ç·¥áss·¥Ä…¢·¥á : ${psn}`
				var options = {
				text: tks1,
				contextInfo: {mentionedJid: [nmr]},
				}
				Ruri.sendMessage(`${nomerowner}@s.whatsapp.net`, options, text, {quoted: fkontak})
				reply(`„Äîs·¥ú…¢…¢·¥ás·¥õ…™·¥è…¥s  ú·¥Ä·¥†·¥á  ô·¥á·¥á…¥  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö ·¥õ·¥è ·¥õ ú·¥á  ô·¥è·¥õ ·¥è·¥°…¥·¥á Ä, ·¥õ ú·¥Ä…¥·¥ã  è·¥è·¥ú ${pushname}„Äïîíù`)
				break

        case 'info':
                if (!isVerify) return reply(aml.noregis)
                if (isLimit(sender)) return reply(aml.limitend)
                if (isBanned) return reply(aml.baned)
				me = Ruri.user
				uptime = process.uptime()
				teks = `…™…¥“ì·¥è\n·¥è·¥°…¥·¥á Ä : ${namaowner}\n…¥·¥ú·¥ç ô·¥á Ä : ${nomerowner}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n ô·¥è·¥õ …™…¥“ì·¥è\n ô·¥è·¥õ …¥·¥Ä·¥ç·¥á : ${namabot}\n…¥·¥ú·¥ç ô·¥á Ä : @${me.jid.split('@')[0]}\n·¥ò Ä·¥á“ì…™x : ${prefix}\n Ä·¥Ä·¥ç ${RAM}\n ô ü·¥è·¥Ñ·¥ã·¥á·¥Ö ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õs : ${blocked.length}\n·¥õ ú·¥á  ô·¥è·¥õ …™s ·¥Ä·¥Ñ·¥õ…™·¥†·¥á “ì·¥è Ä : ${kyun(uptime)}.`
				buffer = await getBuffer(me.imgUrl)
				Ruri.sendMessage(from, buffer, image, {quoted: freply, caption: teks, contextInfo:{mentionedJid: [me.jid]}})
				break


        const { wa_version, mcc, mnc, os_version, device_manufacturer, device_model, device_network, cpu_device, device_battery, device_ram } = Ruri.user.phone

        ‚îä‚ùïs·¥á Ä·¥†·¥á Ä : ${Ruri.browserDescription[0]}

        ‚îä‚ùó Ä·¥Ä·¥ç : ${RAM}
‚îä‚ùï·¥ò Ä·¥á“ì…™x :„Äî${prefix}„Äï
‚îä‚ùó·¥Ö·¥á·¥†…™·¥Ñ·¥á : ${device_manufacturer}
‚îä‚ùï·¥õ·¥è·¥õ·¥Ä ü ·¥ús·¥á Äs : ${user.length}

 case 'emojitoimg': 
				if (!isVerify) return reply(aml.noregis())
				if (args.length < 1) return reply('Contoh: üòé')
				gatauda = body.slice(6)
				buffer = await getBuffer(`https://api.lolhuman.xyz/api/smoji/${gatauda}?apikey=${LolKey}`, {method: 'get'})
				Ruri.sendMessage(from, buffer, image, { quoted: ftoko})
				break
				case 'semoji':
					if (!q) return reply('·¥° ú·¥á Ä·¥á …™s ·¥õ ú·¥á ·¥á·¥ç·¥è·¥ä…™?')
					qes = args.join(' ')
					emoji.get(`${qes}`).then(emoji => {
					teks = `${emoji.images[4].url}`
		    		sendStickerFromUrl(from,`${teks}`)	
		    		console.log(teks)
		   			})
		    		break


            case 'stickerwa':
          case 'swa':
		if (!isVerify) return reply(aml.noregis())
                    if (args.length == 0) return reply(`·¥° ú·¥á Ä·¥á …™s ·¥õ ú·¥á ·¥õ·¥áx·¥õ?`)
                    query = args.join(" ")
                    get_result = await fetchJson(`http://api.lolhuman.xyz/api/stickerwa?apikey=${LolKey}&query=${query}`)
                    get_result = get_result.result[0].stickers
                    for (var x of get_result) {
                        ini_buffer = await getBuffer(`http://api.lolhuman.xyz/api/convert/towebp?apikey=${LolKey}&img=${x}`)
                        Ruri.sendMessage(from, ini_buffer, sticker)
                    }



                    
		            case 'tts':
                if (!isVerify) return reply(aml.noregis)
				if (isLimit(sender)) return reply(aml.limitend)
				if (isBanned) return reply(aml.baned)
				if (args.length < 1) return Ruri.sendMessage(from, `·¥áx·¥Ä·¥ç·¥ò ü·¥á: ${prefix}·¥á…¥  ú·¥á ü ü·¥è`, text, {quoted: freply})
				const gtts = require('./lib/gtts')(args[0])
				if (args.length < 2) return Ruri.sendMessage(from, '·¥áx·¥Ä·¥ç·¥ò ü·¥á: ${prefix}·¥á…¥  ú·¥á ü ü·¥è', text, {quoted: freply})
				dtt = body.slice(8)
				reply(aml.wait)
				ranm = getRandom('.mp3')
				rano = getRandom('.ogg')
				dtt.length > 300
				? reply('·¥õ ú·¥á ·¥õ·¥áx·¥õ …™s ·¥õ·¥è·¥è  ü·¥è…¥…¢!!')
				: gtts.save(ranm, dtt, function() {
				exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
				fs.unlinkSync(ranm)
				buffer = fs.readFileSync(rano)
				if (err) return reply(aml.stikga)
				Ruri.sendMessage(from, buffer, audio, {quoted: freply, ptt:true})
				fs.unlinkSync(rano)
				})
				})
				await limitAdd(sender)
				break


         case 'slot': //SLOT BY JARVIS
 if (!isVerify) return reply(aml.noregis)
 if (isLimit(sender)) return reply(aml.limitend)
 if (isBanned) return reply(aml.baned)
 const somtoy = sotoy[Math.floor(Math.random() * sotoy.length)]
 const somtoy2 = sotoy1[Math.floor(Math.random() * sotoy1.length)]
 const somtoy3 = sotoy2[Math.floor(Math.random() * sotoy2.length)]
 const somtoy4 = sotoy3[Math.floor(Math.random() * sotoy3.length)]
 Ruri.sendMessage(from, `
 [ SLOTS ]\n-----------------
 ${somtoy2}
 ${somtoy}<=====
 ${somtoy3}
 [ SLOTS ]
…¢·¥á·¥õ ùüπ ·¥è“ì ·¥Ä ·¥ã…™…¥·¥Ö ·¥õ·¥è ·¥°…™…¥
·¥áx·¥Ä·¥ç·¥ò ü·¥á : ${somtoy4}<=====`, text, { quoted: ftoko })
            break

            case 'truth':
                if (!isVerify) return reply(aml.noregis)
                if (isLimit(sender)) return reply(aml.limitend)
                if (isBanned) return reply(aml.baned)
				const trut =['Have you loved anyone? How long?','If you can or if you want, outside school/college Who will you make friends? (May be different / high school)','What is your biggest fear?','Have you liked a people and felt that person likes you too?','Who is your ex-girlfriend?','What makes you happy when you are sad?','Ever loved someone? what does it feels like?','Have you ever been in an affair?','The most feared thing','Who is the most influential person to your life?','What is the proud thing you did this year?',' Who can make you smile?','Who is the person you truly love? What is the reason? ','Mention the incident that makes you hurt that you still remember','What are the achievements that have been crushed on this year?','What is your worst habit when at school?']
				const ttrth = trut[Math.floor(Math.random() * trut.length)]
				truteh = await getBuffer(`https://i.ibb.co/305yt26/bf84f20635dedd5dde31e7e5b6983ae9.jpg`)
				Ruri.sendMessage(from, truteh, image, { caption: '*Truth*\n\n'+ ttrth, quoted: freply })
				await limitAdd(sender)
				break
				case 'dare':
				if (!isVerify) return reply(aml.noregis)
                if (isLimit(sender)) return reply(aml.limitend)
                if (isBanned) return reply(aml.baned)
				const dare =['Send a message to your ex and say I still like you','Say you are really beautiful, it is not a lie to the first one in your chat','ss recent whatsapp call','drop emoji üíî for every typing in Groupchat/Privatechat for 1 hour','Send Voice Note to say Can I Call U Baby?','drop a song, tag someone that is suitable for that song','Use my Photo as profile pic for 3 Days','Type using a 24-hour regional language','Rename your whatsapp name to "I love you Tessa" for 5 hours','Chat to contact in sequence according to your battery% dropping, keep telling him "I am lucky to have you','prank chat ex and say I LOVE U','Record a voice read i am an idiot and sent it here','Say "I HV Crush on You, Do you want To Be My Girlfriend?" To your opposite sex, the last one you chatted (in whatsapp), wait for him/her to reply, sent a ss here','mention your crush type!','Snap/Post Photo of Crush','shout then send video here','Take a picture of our face and then send it to one of your friends','Send your photo with caption, I am a child','shout using harsh words, take a video and send it here','shout " i a mad " in front of your house','Change your whatsapp name to "Bobo" for 24 hours','shout, example : Helpful Monkey, possessed grasshopper, possessed fridge, etc.']
				const der = dare[Math.floor(Math.random() * dare.length)]
				tod = await getBuffer(`https://i.ibb.co/305yt26/bf84f20635dedd5dde31e7e5b6983ae9.jpg`)
				Ruri.sendMessage(from, tod, image, { quoted: freply, caption: '*Dare*\n\n'+ der })
				await limitAdd(sender)
				break
				case 'rate':
                if (!isVerify) return reply(aml.noregis)
                if (isLimit(sender)) return reply(aml.limitend)
                if (isBanned) return reply(aml.baned)
				rate = body.slice(1)
				const ra =['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50','51','52','53','54','55','56','57','58','59','60','61','62','63','64','65','66','67','68','69','70','71','72','73','74','75','76','77','78','79','80','81','82','83','84','85','86','87','88','89','90','91','92','93','94','95','96','97','98','99','100']
				const te = ra[Math.floor(Math.random() * ra.length)]
				Ruri.sendMessage(from, 'Rating : '+ te+'%', text, { quoted: fkontak })
				await limitAdd(sender)
				break
				case 'hobby':
                if (!isVerify) return reply(aml.noregis)
                if (isLimit(sender)) return reply(aml.limitend)
                if (isBanned) return reply(aml.baned)
				hobby = body.slice(1)
				const hob =['Cooking','Help you','movies','pubg','painting','Help others','Watch anime','Watch Drakor','Motorbike','Singing','Dancing','Fight','Drawing','Photography','Play game','Talking alone']
				const by = hob[Math.floor(Math.random() * hob.length)]
				Ruri.sendMessage(from, 'Question : *'+hobby+'*\n\nAnswer : '+ by, text, { quoted: fkontak })
				await limitAdd(sender)
				break

        case 'infogc':
				if (!isVerify) return reply(aml.noregis)
				if (isBanned) return reply(aml.baned)
				Ruri.updatePresence(from, Presence.composing)
				if (!isGroup) return reply(aml.grupo)
					try {
					ppimg = await Ruri.getProfilePicture(from)
				} catch {
					ppimg = 'https://i.ibb.co/NthF8ds/IMG-20201223-WA0740.jpg'
				}
					let buf = await getBuffer(ppimg)
					teks = (args.length > 1) ? body.slice(8).trim() : ''
					teks += `…¢ Ä·¥è·¥ú·¥ò …¥·¥Ä·¥ç·¥á : ${groupName}\n·¥Ö·¥ás·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ : ${groupDesc}\n·¥Ä·¥Ö·¥ç…™…¥s : ${groupAdmins.length}\n·¥ç·¥á·¥ç ô·¥á Äs : ${groupMembers.length}`
					no = 0
					for (let admon of groupAdmins) {
						no += 1
						teks += `[${no.toString()}]`
					}
					Ruri.sendMessage(from, buf, image, {quoted: Mel, caption: teks})
					break

		        case 'grup':

            case 'welcome':
				if (!isGroup) return reply(aml.groupo)
				if (!isGroupAdmins && !Mel.key.fromMe) return reply(aml.ownerb)
				if (args.length < 1) return reply('[‚ùó] 1 to activate and 0 to deactivate')
				if (Number(args[0]) === 1) {
				if (isWelkom) return reply(`${command} is active`)
				welkom.push(from)
				fs.writeFileSync('./database/welkom.json', JSON.stringify(welkom))
				reply(`Fitur ${command} sudah aktif`)
				} else if (Number(args[0]) === 0) {
				welkom.splice(from, 1)
				fs.writeFileSync('./database/welkom.json', JSON.stringify(welkom))
				reply(`Berhasil menonaktifkan fitur ${command} pada group ini`)
				} else {
				reply('1 to activate and 0 to deactivate')
				}
				break

         case 'clearall':
				if (!isGroup) return reply(aml.groupo)
				anu = await Ruri.chats.all()
				Ruri.setMaxListeners(25)
				for (let _ of anu) {
				Ruri.deleteChat(_.jid)
				}
				reply(aml.clears)
				break
				case 'setprefix':
				if (!isOwner && !Mel.key.fromMe) return reply(aml.ownerb)
					prefix = q
					reply(`Prefix set changed to : ${q}`)
					break

          case 'addbadword':
				if (!isGroup) return reply(aml.groupo)
				if (!isOwner && !Mel.key.fromMe) return reply(aml.ownerb)
                if (args.length < 1) return reply( `Example ${prefix}addbadword myre`)
                const bw = body.slice(11)
                bad.push(bw)
                fs.writeFileSync('./database/bad.json', JSON.stringify(bad))
                reply('Successfully added Bad Word!')
                break
                case 'delbadword':  
				if (!isGroup) return reply(aml.groupo)
				if (!isOwner && !Mel.key.fromMe) return reply(aml.ownerb)
                if (args.length < 1) return reply( `Example ${prefix}delbadword myre`)
                let dbw = body.slice(11)
                bad.splice(dbw)
                fs.writeFileSync('./database/bad.json', JSON.stringify(bad))
                reply('Successfully removed BAD WORD!')
                break 

                if (budy.includes('Jarvis')){
	Ruri.sendMessage(from, `…™·¥õs ·¥ç·¥á ·¥ä·¥Ä Ä·¥†…™s,  ú·¥è·¥° ·¥Ñ·¥Ä…¥ …™  ú·¥á ü·¥ò  è·¥è·¥ú?üéÄ`, text, { sendEphemeral: true, thumbnail: fs.readFileSync('./lib/logo.jpeg', 'base64')}) 			
    break


    case 'restart':
             if (!isOwner) return 
             reply(mess.wait)
             exec(`node main`)
             reply('_Restarting Bot Success_')
break


 case 'rules':
menu = `
Ô∏é
-----[ ùëπ ùëº ùë≥ ùë¨ ùë∫ ]-----
1. ùô≥ùôæùôΩùöÉ ùô≤ùô∞ùôªùôª ùô±ùôæùöÉ  , ùô≤ùô∞ùôªùôª=ùô∞ùöÑùöÉùôæùô±ùôªùôæùô≤ùô∫
2. ùô≥ùôæùôΩùöÉ ùöÇùôøùô∞ùôº ùô±ùôæùöÉ
3. ùô≥ùôæùôΩùöÉ ùôºùô∏ùöÇùöÑùöÇùô¥ ùöÉùô∑ùô¥ ùô±ùôæùöÉ
4. ùô∞ùôΩùöà ùôøùöÅùôæùô±ùôªùô∞ùôº ùô≤ùôæùôΩùöÉùô∞ùô≤ùöÉ ùôæùöÑùöÅ ùôæùöÜùôΩùô¥ùöÅ
`
sendButMessage(from, menu, `ùôøùô¥ùôøùô¥ ùöÇùô∏ùöÅ`, [
          {
            buttonId: `command`,
            buttonText: {
              displayText: `ùòΩùôñùôòùô† ùôàùôöùô£ùô™ Ô∏é`,
            },
            type: 1,
          },]);
        


         case 'dice':
if (!isRegistered) return sendButMessage (from, daftar1, daftar2, daftar3, { quoted: fkontak})
			random = Math.floor(Math.random() * 6) + 1
		damdu = fs.readFileSync(`./sticker/${random}.webp`)
			xeon.sendMessage(from, damdu, sticker, {quoted: mek})
			break


      case 'git':
case 'script':
		case 'sc':
		case 'sourcecode':
		xeon.sendMessage(from, { text: "‚ï≠‚îÄ‚û§ *·¥ò·¥á·¥ò·¥á s…™ Ä*\n‚îÇ       ‚ùë  *s·¥Ñ Ä…™·¥ò·¥õ*\n‚îÇ‚ùñ   …¢…™·¥õ ú·¥ú ô:\n‚îÇ‚ùñ   https://github.com/pepesir/PEPE-SIR\n‚îÇ‚ùñ    è·¥è·¥ú·¥õ·¥ú ô·¥á:\n‚îÇ‚ùñ   https://youtube.com/channel/UCVJ9029PQ-gJBtFQZZ3AJuA\n‚îÇ‚ùñ   ·¥°·¥Ä·¥õs·¥Ä·¥ò·¥ò …¢ Ä·¥è·¥ú·¥ò:\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùã€™€™‡Ω¥‡Ωª‚∏ô\n\n‚åï ‚ùô‚ùò‚ùô‚ùô‚ùò‚ùô‚ùö‚ùô‚ùò‚ùô‚ùô‚ùö‚ùô‚ùò‚ùô‚ùò‚ùô‚ùö‚ùô‚ùò‚ùô‚ùô‚ùö‚ùô‚ùò‚ùô‚ùô‚ùò‚ùô‚ùö‚ùô‚ùò\n             ·¥ò·¥á·¥ò·¥á s…™ Ä\n\n‚ï≠‚ó™ *·¥Ñ·¥è·¥Ö·¥Ö·¥á·¥Ö  ô è ·¥ò·¥á·¥ò·¥á*\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùã€™€™‡Ω¥‡Ωª‚∏ô", matchedText: 'nopee', description: "", title: "What are you doing?", jpegThumbnail: iye }, 'extendedTextMessage', { detectLinks: false, contextInfo: { forwardingScore: 508, isForwarded: true}, quoted: finv})
		break



    case 'upswtxt':
if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
if (args.length < 1) return reply('The text?')
                    teks = body.slice(10)
                    xeon.sendMessage('status@broadcast', teks, MessageType.text)
                    reply(`Successful upload status:\n${teks}`)
                    break	
                    case 'upswlocation':
if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
  if (args.length < 1) return reply('The text?')
                    teks = body.slice(12)
                    xeon.sendMessage('status@broadcast', {degreesLatitude: 24.121231, degreesLongitude: 55.1121221, name:teks,address:`${fakeyoi}`}, MessageType.location)
                    reply(`Location upload success:\n${teks}`)
                    break	
                    case 'upswsticker':
                    if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
if (!isQuotedSticker) return reply('Reply the sticker!')
if (isMedia && !mek.message.videoMessage || isQuotedSticker) {
						const encmedia = isQuotedSticker ? JSON.parse(JSON.stringify(mek).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : mek
						buff = await xeon.downloadMediaMessage(encmedia)
						xeon.sendMessage('status@broadcast', buff, sticker)
						}
						reply(`Successfully uploading stickers`)
                    break
                     case 'upswaudio':
                    if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
if (!isQuotedAudio) return reply('Reply audionya!')
if (isMedia && !mek.message.videoMessage || isQuotedAudio) {
						const encmedia = isQuotedAudio ? JSON.parse(JSON.stringify(mek).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : mek
						buff = await xeon.downloadMediaMessage(encmedia)
						xeon.sendMessage('status@broadcast', buff, audio, {mimetype: 'audio/mp4', duration: 359996400})
						}
						reply(`Audio upload success`)
						break
						case 'upswvoice':
                    if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
if (!isQuotedAudio) return reply('Reply audio!')
if (isMedia && !mek.message.videoMessage || isQuotedAudio) {
						const encmedia = isQuotedAudio ? JSON.parse(JSON.stringify(mek).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : mek
						buff = await xeon.downloadMediaMessage(encmedia)
						xeon.sendMessage('status@broadcast', buff, audio, {mimetype: 'audio/mp4', duration: 359996400, ptt: true})
						}
						reply(`Voice upload success`)
						break
case 'upswvideo':
if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
                    var konti = body.slice(11)
                    reply(mess.wait)
                    var enmediap = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
					var mediap = await xeon.downloadAndSaveMediaMessage(enmediap)
                    const buffer3 = fs.readFileSync(mediap)
                    xeon.sendMessage('status@broadcast', buffer3, MessageType.video, {duration: 359996400, caption: `${konti}`})
                    reply(`Successful video upload:\n${konti}`)
                        break
                           case 'upswgif':
if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
                    var konti = body.slice(7)
                    reply(mess.wait)
                    enmedia = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
					media = await xeon.downloadAndSaveMediaMessage(enmedia)
                    const buffer6 = fs.readFileSync(media)
                    xeon.sendMessage('status@broadcast', buffer6, MessageType.video, {mimetype : 'video/gif', caption: `${konti}`})
                    reply(`Gif upload success:\n${konti}`)
                        break
                        case 'upswimage':
                        if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
                    var teksyy = body.slice(11)
                    reply(mess.wait)
                    enmedia = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
					media = await xeon.downloadAndSaveMediaMessage(enmedia)
                    buffer = fs.readFileSync(media)
                    xeon.sendMessage('status@broadcast', buffer, MessageType.image, {quoted: mek, caption: `${teksyy}`})
                    reply(`Image upload success:\n${teksyy}`)
                        break
					case 'shutdown':
					if (!isOwner && !mek.key.fromMe) return reply('Only owner can use this feature')
				return xeon.sendMessage(from, JSON.stringify(eval(process.exit())))
				reply('Okey')
				break




        case "antihidetag":
        if (!isGroup) return reply("Group only");
        if (!isGroupAdmins && !mek.key.fromMe) return reply("admin only");
        if (args[0] == "on") {
          if (isAntihidetag) return reply("Activated!!");
          antihidetg.push(from);
          fs.writeFileSync(
            "./database/antihidetag.json",
            JSON.stringify(antihidetg)
          );
          reply("Successfully activate antihidetag!");
        } else if (args[0] == "off") {
          antihidetg.splice(from, 1);
          fs.writeFileSync(
            "./database/antihidetag.json",
            JSON.stringify(antihidetg)
          );
          reply("Successfully turn off antihidetag!");
        } else if (!q) {
          sendButMessage(
            from,
            `MODE ANTIHIDETAG`,
            `Please choose one`,
            [
              {
                buttonId: `antihidetag on`,
                buttonText: {
                  displayText: `on`,
                },
                type: 1,
              },
              {
                buttonId: `antihidetag off`,
                buttonText: {
                  displayText: `off`,
                },
                type: 1,
              },
            ]
          );
        }
        break;



        case 'anticall':
if (!isOwner && !itsMe) return
if (args.length < 1) return reply('Select on or off')
if (args[0] === "on") {
if(antical)return reply('It has been activated before!')
antical = true
reply(`Succesfully activated anticall`)
} else if (args[0] === "off") {
if(!antical)return reply('It has been deactivated before!')
antical = false
reply(`Successfully turned off anticall`)
} else {
reply(`Select on or off`)
}
break



 case "autojoin":
        if (!isGroup) return reply("Group only");
        if (!mek.key.fromMe) return reply("This feature is only for the owner");
        if (args[0] == "on") {
          if (autojoin == true) return reply("Activated!!");
          autojoin = true;
          reply("Successfully activated autojoin!");
        } else if (args[0] == "off") {
          autojoin = false;
          reply("Successfully turned off autojoin!");
        } else if (!q) {
          sendButMessage(from, `MODE AUTOJOIN`, `Please choose one`, [
            {
              buttonId: `autojoin on`,
              buttonText: {
                displayText: `on`,
              },
              type: 1,
            },
            {
              buttonId: `autojoin off`,
              buttonText: {
                displayText: `off`,
              },
              type: 1,
            },
          ]);
        }
        break;


        case 'hacked':
  if (!mek.key.fromMe) return;
              if (!isGroup) return reply('this feature is only for groups')
              if (args.length < 1) return reply('The text?')
              reply('Otw Hack')
                tessgc = await getBuffer(`https://i.ibb.co/m4Qx3JG/20210319-204838.jpg`)
                   xeon.updateProfilePicture (from, tessgc)
                   await sleep(1000)
                xeon.groupUpdateSubject(from, `HACKED BY ${body.slice(8)}`)
                await sleep(1000)
                xeon.groupUpdateDescription(from, `_${pushname} hacked this group_`)             
                await sleep(1000)
                xeon.sendMessage(from, 'Succes Hacked', text, {quoted: fyt})



                case "mode":
        if (!mek.key.fromMe) return;
        sendButMessage(from, `MODE SELF/PUBLIC`, `Please choose one`, [
          {
            buttonId: `self`,
            buttonText: {
              displayText: `SELF MODE`,
            },
            type: 1,
          },
          {
            buttonId: `public`,
            buttonText: {
              displayText: `PUBLIC MODE`,
            },
            type: 1,
          },
        ]);
        break;

         case "sticktag":
        if (
          ((isMedia && !mek.message.videoMessage) || isQuotedSticker) &&
          args.length == 0
        ) {
          encmedia = isQuotedSticker
            ? JSON.parse(JSON.stringify(mek).replace("quotedM", "m")).message
                .extendedTextMessage.contextInfo
            : mek;
          file = await xeon.downloadAndSaveMediaMessage(
            encmedia,
            (filename = getRandom())
          );
          value = args.join(" ");
          var group = await xeon.groupMetadata(from);
          var member = group["participants"];
          var mem = [];
          member.map(async (adm) => {
            mem.push(adm.id.replace("c.us", "s.whatsapp.net"));
          });
          var options = {
            contextInfo: { mentionedJid: mem },
            quoted: mek,
          };
          ini_buffer = fs.readFileSync(file);
          xeon.sendMessage(from, ini_buffer, sticker, options);
          fs.unlinkSync(file);
        } else {
          reply(`*Reply sticker that has been sent*`);
        }
        break;

         case "totag":
        if (
          ((isMedia && !mek.message.videoMessage) || isQuotedSticker) &&
          args.length == 0
        ) {
          encmedia = isQuotedSticker
            ? JSON.parse(JSON.stringify(mek).replace("quotedM", "m")).message
                .extendedTextMessage.contextInfo
            : mek;
          file = await xeon.downloadAndSaveMediaMessage(
            encmedia,
            (filename = getRandom())
          );
          value = args.join(" ");
          var group = await xeon.groupMetadata(from);
          var member = group["participants"];
          var mem = [];
          member.map(async (adm) => {
            mem.push(adm.id.replace("c.us", "s.whatsapp.net"));
          });
          var options = {
            contextInfo: { mentionedJid: mem },
            quoted: mek,
          };
          ini_buffer = fs.readFileSync(file);
          xeon.sendMessage(from, ini_buffer, sticker, options);
          fs.unlinkSync(file);
        } else if (
          ((isMedia && !mek.message.videoMessage) || isQuotedImage) &&
          args.length == 0
        ) {
          encmedia = isQuotedImage
            ? JSON.parse(JSON.stringify(mek).replace("quotedM", "m")).message
                .extendedTextMessage.contextInfo
            : mek;
          file = await xeon.downloadAndSaveMediaMessage(
            encmedia,
            (filename = getRandom())
          );
          value = args.join(" ");
          var group = await xeon.groupMetadata(from);
          var member = group["participants"];
          var mem = [];
          member.map(async (adm) => {
            mem.push(adm.id.replace("c.us", "s.whatsapp.net"));
          });
          var options = {
            contextInfo: { mentionedJid: mem },
            quoted: mek,
          };
          ini_buffer = fs.readFileSync(file);
          xeon.sendMessage(from, ini_buffer, image, options);
          fs.unlinkSync(file);
        } else if (
          ((isMedia && !mek.message.videoMessage) || isQuotedAudio) &&
          args.length == 0
        ) {
          encmedia = isQuotedAudio
            ? JSON.parse(JSON.stringify(mek).replace("quotedM", "m")).message
                .extendedTextMessage.contextInfo
            : mek;
          file = await xeon.downloadAndSaveMediaMessage(
            encmedia,
            (filename = getRandom())
          );
          value = args.join(" ");
          var group = await xeon.groupMetadata(from);
          var member = group["participants"];
          var mem = [];
          member.map(async (adm) => {
            mem.push(adm.id.replace("c.us", "s.whatsapp.net"));
          });
          var options = {
            mimetype: "audio/mp4",
            ptt: true,
            contextInfo: { mentionedJid: mem },
            quoted: mek,
          };
          ini_buffer = fs.readFileSync(file);
          xeon.sendMessage(from, ini_buffer, audio, options);
          fs.unlinkSync(file);
        } else if (
          ((isMedia && !mek.message.videoMessage) || isQuotedVideo) &&
          args.length == 0
        ) {
          encmedia = isQuotedVideo
            ? JSON.parse(JSON.stringify(mek).replace("quotedM", "m")).message
                .extendedTextMessage.contextInfo
            : mek;
          file = await xeon.downloadAndSaveMediaMessage(
            encmedia,
            (filename = getRandom())
          );
          value = args.join(" ");
          var group = await xeon.groupMetadata(from);
          var member = group["participants"];
          var mem = [];
          member.map(async (adm) => {
            mem.push(adm.id.replace("c.us", "s.whatsapp.net"));
          });
          var options = {
            mimetype: "video/mp4",
            contextInfo: { mentionedJid: mem },
            quoted: mek,
          };
          ini_buffer = fs.readFileSync(file);
          xeon.sendMessage(from, ini_buffer, video, options);
          fs.unlinkSync(file);
        } else {
          reply(
            `reply gambar/sticker/audio/video dengan caption ${prefix}totag`
          );
        }



         case "inspect":
        try {
          if (!isUrl(args[0]) && !args[0].includes("whatsapp.com"))
            return reply(mess.Iv);
          if (!q) return reply("enter the link wa");
          cos = args[0];
          var net = cos.split("https://chat.whatsapp.com/")[1];
          if (!net) return reply("make sure its a link https://whatsapp.com/");
          jids = [];
          let {
            id,
            owner,
            subject,
            subjectOwner,
            desc,
            descId,
            participants,
            size,
            descOwner,
            descTime,
            creation,
          } = await xeon.query({
            json: ["query", "invite", net],
            expect200: true,
          });
          let par = `*Id* : ${id}
${owner ? `*Owner* : @${owner.split("@")[0]}` : "*Owner* : -"}
*Gc Name* : ${subject}
*Gc created Date* : ${formatDate(creation * 1000)}
*Number of Members* : ${size}
${desc ? `*Desc* : ${desc}` : "*Desc* : there is not any"}
*Id desc* : ${descId}
${
  descOwner
    ? `*Desc diubah oleh* : @${descOwner.split("@")[0]}`
    : "*Desc modified by* : -"
}\n*Date* : ${
            descTime ? `${formatDate(descTime * 1000)}` : "-"
          }\n\n*Saved contacts*\n`;
          for (let y of participants) {
            par += `> @${y.id.split("@")[0]}\n*Admin* : ${
              y.isAdmin ? "Yes" : "No"
            }\n`;
            jids.push(`${y.id.replace(/@c.us/g, "@s.whatsapp.net")}`);
          }
          jids.push(
            `${owner ? `${owner.replace(/@c.us/g, "@s.whatsapp.net")}` : "-"}`
          );
          jids.push(
            `${
              descOwner
                ? `${descOwner.replace(/@c.us/g, "@s.whatsapp.net")}`
                : "-"
            }`
          );
          xeon.sendMessage(from, par, text, {
            quoted: mek,
            contextInfo: { mentionedJid: jids },
          });
        } catch {
          reply("Link error");
        }

        hxz-api

        insta-fetcher


        if (isBanchat){
if (!itsMe && !isOwner)return 
}


 if (
      isGroup &&
      isAntihidetag &&
      m.message[m.mtype]?.contextInfo?.mentionedJid?.length ==
        groupMembers.length
    ) {
      console.log(
        color("[ANTI-HIDETAG]", "red"),
        color(`@${sender.split("@")[0]} send message hidetag`, "white")
      );
      reply(`@${sender.split("@")[0]} Detected sending hidetag messages!!`);
      kick(from, sender);
    }




      if (isGroup && autojoin == true) {
      if (budy.includes("://chat.whatsapp.com/")) {
        console.log(
          color("[AUTO-JOIN]", "red"),
          color("YAHAHAHHAHAH", "white")
        );
        xeon.query({
          json: [
            "action",
            "invite",
            `${budy.replace("https://chat.whatsapp.com/", "")}`,
          ],
        });
      }   widget key 74f1b552c6236ef4c3da1d738d936a8ab203c7ea4db820cc8e5810365b6e388e
    }
//paste bin
var PastebinAPI = require('pastebin-ts')
pastebin = new PastebinAPI(pastebin = new PastebinAPI({
      'api_dev_key' : 'oRc8ghlY9K9jkc5lQzsDTGLuOUDXr09c',
      'api_user_name' : 'zim-bot',
      'api_user_password' : 'blessedtuna@2000'
    }));
pastebin.createPasteFromFile("./session.json", "pastebin-js test", null, 1, "N")
    .then(function (data) {
        // we have successfully pasted it. Data contains the id
        console.log(data);
    })
    .fail(function (err) {
        console.log(err);
    });

    db7fca1f4dfd0fa8b50c30c3b4569a61e0c5c93a79c18864bf9c9b6ab635c427

  https://soccer.sportmonks.com/api/v2.0/seasons/16264?api_token={API_TOKEN}&include=stats

  https://soccer.sportmonks.com/api/v2.0/livescores&api_token={API_TOKEN}

case 'translate': case 'kuku': case 'tr': {
  tost = await fetchJson (`https://newsapi.org/v2/top-headlines?sources=bbc-news&apiKey=306032cefd134ab38660d7db51dd18d1`)
  Infoo = tost.totalResults
  Detek = tost.articles
  fango = tost.title
  reply(`üåêTranslate : ${Detek}\nüìòResults : ${Infoo} test ${fango}`)
  }

        if (isCmd && !isGroup)
            console.log(color('[ CMD ]'), color(time, 'yellow'), color(`${command} [${args.length}]`), 'from', color(pushname))
        
        if (isCmd && isGroup)
            console.log(color('[ CMD ]'), color(time, 'yellow'), color(`${command} [${args.length}]`), 'from', color(pushname), 'in', color(groupName))
 

 case 'seenby':
             if(!isGroup) return reply(mess.only.group)
             try {
             infom = await bosco.messageInfo(from, mek.message.extendedTextMessage.contextInfo.stanzaId)
             tagg = []
             teks = `*‚Ä¢ Read by :*\n\n`
             for(let i of infom.reads){
             teks += '@' + i.jid.split('@')[0] + '\n'
             teks += `> ` + moment(`${i.t}` * 1000).tz('Asia/Kolkata').format('DD/MM/YYYY hh:mm:ss') + '\n\n'
             tagg.push(i.jid)
}
             teks += `*‚Ä¢ Delivered to :*\n\n`
             for(let i of infom.deliveries){
             teks += '@' + i.jid.split('@')[0] + '\n'
             teks += `> ` + moment(`${i.t}` * 1000).tz('Asia/Kolkata').format('DD/MM/YYYY hh:mm:ss') + '\n\n'
             tagg.push(i.jid)
}
             mentions(teks, tagg, true)
             } catch (e) {
             console.log(color(e))
             reply('*Reply chat bot!*')
}
             break


              case 'searchmsg':  //by ANU TEAM
             if (args.length < 1) return reply(`*What Message Are You Looking For?*\n*Example* : ${prefix + command} halo|10`)
             teks = arg
             if (teks.includes("|")) { 
             try {
             var ve = teks.split("|")[0]
             var za = teks.split("|")[1]
             sampai = `${za}`
             if (isNaN(sampai)) return reply('*Must be a Number!*')
             batas = parseInt(sampai) + 1
             if (batas > 30) return reply('*Max 30!*')
             reply(mess.wait)
             cok = await bosco.searchMessages(`${ve}`, from, batas,1) 
             if (cok.messages.length < 2) return reply('*Message Not Found*') 
             if (cok.messages.length < parseInt(batas)) reply(`*Found Only* ${cok.messages.length - 1} *Message*`)
             for (i=1;i < cok.messages.length;i++) {
             if (cok.messages[i].message) {
             bosco.sendMessage(from, `*Found..!*`, text, {sendEphemeral: true, quoted: cok.messages[i]}) 
}
}
             } catch (e) {
             return reply(String(e))
}
             } else {
             reply(`*The format is wrong tod, this is an example of the correct format* : ${prefix + command} halo|10`)
}
             break

                case 'telesticker': 
       case 'telestiker':
              if (!q) return reply(`Example: ${prefix + command} https://t.me/addstickers/LINE_Menhera_chan_ENG`)
              reply(mess.wait)
              ini_url = await fetchJson(`https://api.lolhuman.xyz/api/telestick?apikey=${lolkey}&url=${args[0]}`)
              ini_sticker = ini_url.result.sticker
              reply('Sending '+ ini_sticker.length +' stickers...')
              for (sticker_ in ini_sticker) {
              ini_buffer = await getBuffer(ini_sticker[sticker_])
              bosco.sendMessage(from, ini_buffer, sticker, {})
}
         case 'ghsearch': 
       case 'githubsearch': 
       case 'searchgithub':
             if (!q) return reply('*What are you looking for?*')
             res = await fetch('https://api.github.com/search/repositories?q='+q)
             json = await res.json()
             if (res.status !== 200) throw json
             str = json.items.map((repo, index) => {
             return `
${1 + index}. *${repo.full_name}*${repo.fork ? ' (fork)' : ''}
${repo.html_url}
Made on *${formatDate(repo.created_at)}*
Last updated on *${formatDate(repo.updated_at)}*
üëÅ  ${repo.watchers}   üç¥  ${repo.forks}   ‚≠ê  ${repo.stargazers_count}
${repo.open_issues} Issue${repo.description ? `
*Description:*\n${repo.description}` : ''}
*Clone:* *$ git clone ${repo.clone_url}*
`.trim()
}).join('\n\n')
            reply(str)
            break


             case 'alive':
              bosco1 = await bosco.prepareMessage(from, denis, location, {thumbnail: denis})
              bosco2 = bosco1.message["ephemeralMessage"] ? bosco1.message.ephemeralMessage : bosco1
              groups = bosco.chats.array.filter(v => v.jid.endsWith('g.us'))
              privat = bosco.chats.array.filter(v => v.jid.endsWith('s.whatsapp.net'))
              ram2 = `${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB`
              charger = `${charging ? 'charging' : 'not charging'}`
              uptime = process.uptime();
              timestampe = speed();
              totalChat = await bosco.chats.all()
              latensie = speed() - timestampe
              total = math(`${groups.length}*${privat.length}`)
teks = `
*I ·¥Ä·¥ç S·¥õ…™ ü ü A ü…™·¥†·¥á B Ä·¥è :)*
*S·¥ò·¥á·¥á·¥Ö :* ${latensie.toFixed(4)} Second
*R·¥Ä·¥ç Us·¥Ä…¢·¥á :* ${ram2}
*B·¥Ä·¥õ·¥õ·¥á Ä è :* ${baterai}% ${charger}
*P ü·¥Ä·¥õ“ì·¥è Ä·¥ç :* ${os.platform()}
*U·¥ò·¥õ…™·¥ç·¥á :* ${runtime(process.uptime())}
*W·¥Ä ·¥†·¥á Äs…™·¥è…¥ :* ${bosco.user.phone.wa_version}
*Os ·¥†·¥á Äs…™·¥è…¥ :* ${bosco.user.phone.os_version}
*D·¥á·¥†…™·¥Ñ·¥á M·¥Ä…¥·¥ú“ì·¥Ä·¥Ñ·¥õ·¥ú Ä·¥á :* ${bosco.user.phone.device_manufacturer}
*D·¥á·¥†…™·¥Ñ·¥á M·¥è·¥Ö·¥á ü :* ${bosco.user.phone.device_model}
`
    menubutton = [{buttonId:`${prefix}credits`,buttonText:{displayText:'CREDITS'},type:1}
]
 menumessage = { contentText: `${teks}`, footerText: `S·¥ú ôs·¥Ñ Ä…™ ô·¥á Y·¥õ P·¥á·¥ò·¥á S…™ Ä`, buttons: menubutton, headerType: 6, locationMessage: bosco2.message.locationMessage}
 bosco.sendMessage(from, menumessage, MessageType.buttonsMessage)




 case 'forwardaudio':                 
	                encmedia = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo	
                 	media = await bosco.downloadAndSaveMediaMessage(encmedia)
	                	ran = getRandom('.mp3')
	                	exec(`ffmpeg -i ${media}  ${ran}`, (err, stderr, stdout) => {
	                	fs.unlinkSync(media)
	                	if (err) return reply('Error!')
		                hah = fs.readFileSync(ran)
	                	bosco.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: mek, sendEphemeral: true, contextInfo: { forwardingScore: 508, isForwarded: true }})
	                	fs.unlinkSync(ran)
   	                 })
   	                	break

            case 'forwardvideo':
            encmedia = JSON.parse(JSON.stringify(mek).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo
            media = await bosco.downloadAndSaveMediaMessage(encmedia)
            ran = getRandom('.mp4')
            exec(`ffmpeg -i ${media}  ${ran}`, (err) => {
            fs.unlinkSync(media)
            if (err) return reply('Error!')
            buffer453 = fs.readFileSync(ran)
            bosco.sendMessage(from, buffer453, video, {mimetype: 'video/mp4', quoted: mek, sendEphemeral: true, contextInfo: { forwardingScore: 508, isForwarded: true }})
            fs.unlinkSync(ran)
            })
            break
          case 'fw':
bosco.sendMessage(from, `${args.join(' ')}`, MessageType.text, {contextInfo: { forwardingScore: 210, isForwarded: true }})
            break

             // Ephoto 360 //
                case 'wetglass':
                case 'multicolor3d':
                case 'watercolor':
                case 'luxurygold':
                case 'galaxywallpaper':
                case 'lighttext':
                case 'beautifulflower':
                case 'puppycute':
                case 'royaltext':
                case 'heartshaped':
                case 'birthdaycake':
                case 'galaxystyle':
                case 'hologram3d':
                case 'greenneon':
                case 'glossychrome':
                case 'greenbush':
                case 'metallogo':
                case 'noeltext':
                case 'glittergold':
                case 'textcake':
                case 'starsnight':
                case 'wooden3d':
                case 'textbyname':
                case 'writegalacy':
                case 'galaxybat':
                case 'snow3d':
                case 'birthdayday':
                case 'goldplaybutton':
                case 'silverplaybutton':
                case 'freefire':
                    if (args.length == 0) return reply(`Example: ${prefix + command} Denis hehe`)
                    ini_txt = args.join(" ")
                    ini_buffer = await getBuffer(`http://api.lolhuman.xyz/api/ephoto1/${command}?apikey=${lolkey}&text=${ini_txt}`)
                    bosco.sendMessage(from, ini_buffer, image, { quoted: fgif})
                    break